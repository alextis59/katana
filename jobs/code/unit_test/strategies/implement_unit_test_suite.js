const Job = require('../../../../lib/jobs/Job'),
    target_model = require('../../../model/target_model'),
    _ = require('lodash'),
    config = require('../../../../config'),
    utils = require('../../../../lib/utils'),
    extract = require('../../../../parsing/extract'),
    template_builder = require('../../../../lib/template_builder'),
    { pipe } = require('../../../../lib/jobs/jobs');

let file_prefix = "/**\n * Generated by Katana\n */\n\n";

class ImplementUnitTestSuite extends Job {

    name = 'implement_unit_test_suite';

    description = 'Implement and validate unit tests suite for a function or class';

    inputs = {
        project: {
            type: 'Project',
            description: 'Target project'
        },
        file: {
            type: 'File',
            description: "File object corresponding to the function's module"
        },
        target: target_model,
        target_suffix: {
            type: 'string',
            description: 'Suffix of the target',
            optional: true
        },
        unit_test_cases: {
            type: 'array',
            description: 'Description of the test case'
        },
        existing_test_code_map: {
            type: 'object',
            description: 'Map of existing test codes for which to skip the implementation',
            optional: true
        },
        additional_instructions: {
            type: 'array',
            description: 'Additional instructions to the AI',
            optional: true
        },
        async: {
            type: 'boolean',
            description: 'Whether to process the tests asynchronously or not',
            default_value: false
        },
        unit_test_output_path: {
            type: 'string',
            description: 'Path to the unit test folder',
            optional: true
        },
        test_framework: {
            type: 'string',
            description: 'Test framework to use',
            default_value: 'jest'
        },
        skip_failed_tests: {
            type: 'boolean',
            description: 'Whether to skip failed tests or not',
            default_value: false
        },
        on_test_implemented: {
            type: 'function',
            description: 'Function to call after each test is implemented',
            optional: true
        },
    };

    outputs = {
        test_code: {
            type: 'string',
            description: 'Code of the unit tests suite'
        },
        test_code_list: {
            type: 'array',
            description: 'Separated list of test codes'
        },
        passing_test_list: {
            type: 'array',
            description: 'List of booleans indicating if the tests are passing'
        }
    };

    execute = async (context) => {
        let unit_test_cases = context.unit_test_cases,
            existing_test_code_map = context.existing_test_code_map || {},
            file = context.file,
            target = context.target,
            results = [];

        if (context.async) {
            console.log('Processing tests asynchronously');
            let promises = [];
            for (let i = 0; i < unit_test_cases.length; i++) {
                if (existing_test_code_map[i]) {
                    results.push({
                        test_code: existing_test_code_map[i],
                        passing_test: true,
                        test_index: i
                    });
                }else{
                    promises.push(processTestCase(this.jobs, context, unit_test_cases[i], i, results, context.on_test_implemented))
                }
            }
            await utils.awaitAll(promises);
        } else {
            console.log('Processing tests synchronously');
            for (let i = 0; i < unit_test_cases.length; i++) {
                if (existing_test_code_map[i]) {
                    results.push({
                        test_code: existing_test_code_map[i],
                        passing_test: true,
                        test_index: i
                    });
                } else {
                    await processTestCase(this.jobs, context, unit_test_cases[i], i, results, context.on_test_implemented);
                }
            }
        }
        results = _.sortBy(results, 'test_index');
        let test_code_list = [],
            passing_test_list = [],
            failed_test_index_list = [];
        for (let result of results) {
            test_code_list.push(result.test_code);
            passing_test_list.push(result.passing_test);
            if (!result.passing_test) {
                failed_test_index_list.push(result.test_index);
            }
        }

        let unit_test_output_path = utils.computeFunctionTargetPath(context.unit_test_output_path || config.project.unit_test_output_path, file, target.name, '.test.js'),
            back_folder_count = unit_test_output_path.split('/').length - 1,
            module_path = '../'.repeat(back_folder_count) + file.path_without_filename + '/' + file.name;
        
        if(file.path_without_filename === ''){
            module_path = '../'.repeat(back_folder_count - 1) + '/' + file.name;
        }

        let merged_tests = template_builder.getMergedTestsFile(context.project, file, target.type, target.name, test_code_list, module_path, {
            test_framework: context.test_framework,
            skip_tests: context.skip_failed_tests ? failed_test_index_list : []
        });

        return {
            test_code: file_prefix + merged_tests,
            test_code_list,
            passing_test_list
        }
    }

}

async function processTestCase(jobs, context, test_case, test_index, results, on_test_implemented = () => {}) {
    let result = await jobs.implement_unit_test({
        project: context.project,
        file: context.file,
        target: context.target,
        target_suffix: context.target_suffix,
        code: context.code,
        test_case: test_case,
        additional_instructions: context.additional_instructions,
        test_index: test_index,
        chat_options: context.chat_options
    });
    results.push({
        test_code: result.test_code,
        passing_test: result.passing_test,
        test_index
    });
    if (on_test_implemented) {
        on_test_implemented(result);
    }
}

module.exports = ImplementUnitTestSuite;